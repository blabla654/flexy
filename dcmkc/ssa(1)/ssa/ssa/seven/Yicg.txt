%{
#include"y.tab.h"
#include<stdio.h>
char addtotable(char,char,char);


int index1=0;
char temp = 'A'-1;


struct expr{

char operand1;
char operand2;
char operator;
char result;
};



%}

%union{
char symbol;
}




%left '+' '-'
%left '/' '*'

%token <symbol> LETTER NUMBER
%type <symbol> exp
%%

statement: LETTER '=' exp ';' {addtotable((char)$1,(char)$3,'=');};
exp: exp '+' exp {$$ = addtotable((char)$1,(char)$3,'+');}
    |exp '-' exp {$$ = addtotable((char)$1,(char)$3,'-');}
    |exp '/' exp {$$ = addtotable((char)$1,(char)$3,'/');}
    |exp '*' exp {$$ = addtotable((char)$1,(char)$3,'*');}
    |'(' exp ')' {$$= (char)$2;}
    |NUMBER {$$ = (char)$1;}
    |LETTER {(char)$1;};

%%

struct expr arr[20]; 

void yyerror(char *s){
    printf("Errror %s",s);
}

char addtotable(char a, char b, char o){
    temp++;
    arr[index1].operand1 =a;
    arr[index1].operand2 = b;
    arr[index1].operator = o;
    arr[index1].result=temp;
    index1++;
    return temp;
}

void threeAdd(){

    int i=0;
    char temp='A';
    while(i<index1){
        printf("%c:=\t",arr[i].result);
        printf("%c\t",arr[i].operand1);
        printf("%c\t",arr[i].operator);
        printf("%c\t",arr[i].operand2);
        i++;
        temp++;
        printf("\n");
    }
}

void fouradd(){
    int i=0;
    char temp='A';
    while(i<index1){
        printf("%c\t",arr[i].operator);
        printf("%c\t",arr[i].operand1);
        printf("%c\t",arr[i].operand2);
        printf("%c",arr[i].result);
        i++;
        temp++;
        printf("\n");
    }

}

int find(char l){
    int i;
    for(i=0;i<index1;i++)
        if(arr[i].result==l) break;
    return i;
}



void triple(){
    int i=0;
    char temp='A';
    while(i<index1){
        printf("%c\t",arr[i].operator);
        if(!isupper(arr[i].operand1))
        printf("%c\t",arr[i].operand1);
        else{
            printf("pointer");  
            printf("%d\t",find(arr[i].operand1));
        }
        if(!isupper(arr[i].operand2))
        printf("%c\t",arr[i].operand2);
        else{
            printf("pointer"); 
            printf("%d\t",find(arr[i].operand2));
        }
        i++;
        temp++;
        printf("\n");
    }

}


int yywrap(){
    return 1;
}

int main(
){
    printf("Enter the expression: ");
    yyparse();
    threeAdd();
    printf("\n");
    fouradd();
    printf("\n");
    triple();
    return 0;
}







This code is a combination of Flex and Bison specifications used for parsing and evaluating arithmetic expressions. It includes a mechanism to convert expressions into three address codes and other intermediate representations. Let's go through the code line by line:

Header Section
c
Copy code
%{
#include "y.tab.h"
#include <stdio.h>
char addtotable(char, char, char);

int index1 = 0;
char temp = 'A'-1;

struct expr {
    char operand1;
    char operand2;
    char operator;
    char result;
};
%}
%{ %}: Delimits C code that will be copied into the generated parser.
#include "y.tab.h": Includes the header file generated by Bison.
#include <stdio.h>: Includes the standard input-output library for functions like printf.
char addtotable(char, char, char);: Function prototype for addtotable.
int index1 = 0;: Index for the arr array, which stores intermediate code representations.
char temp = 'A'-1;: Temporary variable used for generating intermediate variable names.
struct expr: Defines a structure to store the operands, operator, and result of each expression.
Bison Declarations
c
Copy code
%union {
    char symbol;
}

%left '+' '-'
%left '/' '*'

%token <symbol> LETTER NUMBER
%type <symbol> exp
%union: Defines the type of semantic values used by Bison. Here, it defines symbol as a char.
%left: Declares left-associative operators with their precedence. Here, '+' and '-' have the same precedence, and '/' and '*' have higher precedence.
%token <symbol> LETTER NUMBER: Declares tokens LETTER and NUMBER of type symbol.
%type <symbol> exp: Declares the type of the non-terminal exp as symbol.
Grammar Rules Section
c
Copy code
%%
statement: LETTER '=' exp ';' { addtotable((char)$1, (char)$3, '='); };
exp: exp '+' exp { $$ = addtotable((char)$1, (char)$3, '+'); }
   | exp '-' exp { $$ = addtotable((char)$1, (char)$3, '-'); }
   | exp '/' exp { $$ = addtotable((char)$1, (char)$3, '/'); }
   | exp '*' exp { $$ = addtotable((char)$1, (char)$3, '*'); }
   | '(' exp ')' { $$ = (char)$2; }
   | NUMBER { $$ = (char)$1; }
   | LETTER { $$ = (char)$1; };
%%: Marks the beginning and end of the grammar rules section.
statement: A rule that matches an assignment statement. It calls addtotable to process the assignment.
exp: Rules that match arithmetic expressions and return the result of operations. Each operation adds an entry to the arr array using addtotable.
Code Section
c
Copy code
%%

struct expr arr[20];

void yyerror(char *s) {
    printf("Error: %s\n", s);
}

char addtotable(char a, char b, char o) {
    temp++;
    arr[index1].operand1 = a;
    arr[index1].operand2 = b;
    arr[index1].operator = o;
    arr[index1].result = temp;
    index1++;
    return temp;
}

void threeAdd() {
    int i = 0;
    while (i < index1) {
        printf("%c := %c %c %c\n", arr[i].result, arr[i].operand1, arr[i].operator, arr[i].operand2);
        i++;
    }
}

void fouradd() {
    int i = 0;
    while (i < index1) {
        printf("%c %c %c %c\n", arr[i].operator, arr[i].operand1, arr[i].operand2, arr[i].result);
        i++;
    }
}

int find(char l) {
    int i;
    for (i = 0; i < index1; i++)
        if (arr[i].result == l) break;
    return i;
}

void triple() {
    int i = 0;
    while (i < index1) {
        printf("%c\t", arr[i].operator);
        if (!isupper(arr[i].operand1))
            printf("%c\t", arr[i].operand1);
        else {
            printf("pointer %d\t", find(arr[i].operand1));
        }
        if (!isupper(arr[i].operand2))
            printf("%c\t", arr[i].operand2);
        else {
            printf("pointer %d\t", find(arr[i].operand2));
        }
        i++;
        printf("\n");
    }
}

int yywrap() {
    return 1;
}

int main() {
    printf("Enter the expression: ");
    yyparse();
    threeAdd();
    printf("\n");
    fouradd();
    printf("\n");
    triple();
    return 0;
}
%%: Marks the end of the grammar rules section.
struct expr arr[20];: Declares an array of expr structures to store intermediate code representations.
void yyerror(char *s): Error handling function that prints an error message.
char addtotable(char a, char b, char o): Adds an entry to the arr array for an operation, updates temp, and returns the result.
void threeAdd(): Prints the three-address code representation of the expressions.
void fouradd(): Prints the quadruple representation of the expressions.
int find(char l): Finds the index of a result in the arr array.
void triple(): Prints the triple representation of the expressions.
int yywrap(): Function called by the lexer at the end of the input, returning 1 to indicate no more input.
int main(): The main function that initiates parsing and prints the intermediate representations.
Summary
This code defines a lexer and parser for simple arithmetic expressions.
It constructs intermediate representations (three-address code, quadruples, and triples) and prints them after parsing.
It includes error handling and supports basic arithmetic operations and parentheses.



